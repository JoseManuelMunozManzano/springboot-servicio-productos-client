# Se van a dejar los puertos de forma automática. La idea es que Spring, de forma automática, asigne el puerto a
# nuestra aplicación. Así queda mucho más escalable y no tenemos que configurar el despliegue indicando
# los puertos.
# Se deja el server.port a 0 y damos una instance-id de servicio con un valor aleatorio que incluya el nombre
# de la aplicación.
#
# Se usa esta configuración solo en aquellos microservicios que queremos escalar de forma automática, donde queremos
# tener varias instancias para el balanceo de carga.
spring.application.name=servicio-productos
server.port=${PORT:0}

eureka.instance.instance-id=${spring.application.name}:${spring.integration.instance_id:${random.value}}

# Se indica el servidor Eureka.
# Esto es opcional si el servidor de Eureka se encuentra en el mismo servidor que los clientes.
# Si están en máquinas distintas entonces si es obligatorio indicar la ubicación física del servidor Eureka
# (nombre de dominio o máquina y puerto)
# Esto es así porque cada cliente, una vez que se despliega, ya sea en la nube o en un servidor local,
# se tiene que registrar, tiene que avisar al servidor de Eureka con una señal, y por eso necesitamos su ubicación física.
# Esta señal se conoce como heartbeat (latido de corazón)
# Una vez registrado, el servidor le pasa el registro completo de los demás microservicios. Esta señal se envía
# cada 30 segundos, para indicar que sigue funcionando.
# Si en 90 segundos no se registra señal, Eureka lo elimina de su registro.
# Se vuelve a registrar en el servidor Eureka después de que se envían 3 señales, es decir, después de 90 segundos.
eureka.client.service-url.defaultZone=http://localhost:8761/eureka